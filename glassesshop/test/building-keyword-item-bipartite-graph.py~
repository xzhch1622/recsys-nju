import csv
import collections

def sieve(predicate, iterable):
    qualified = []
    unqualified = []
    for elem in iterable:
        if predicate(elem):
            qualified.append(elem)
        else:
            unqualified.append(elem)
    return qualified, unqualified

class Node:
    def __init__(self, name, is_keyword=True):
        self.name = name
        self.is_keyword = is_keyword
        self.adjacent = set()
        self.is_colored = False
        self.color = None

    def add_adjacent(self, node):
        self.adjacent.add(node)

    def adjacent_iter(self):
        return self.adjacent

    def set_color(self, color):
        self.is_colored = True
        self.color = color

    def __str__(self):
        return self.name

    def __repr__(self):
        _type = 'Keyword' if self.is_keyword else 'Product'
        return '[%s - %s]' % (_type, self.name)

def _dfs_color(color, node, nodes):
    node.set_color(color)
    nodes.add(node)
    for adjacent_node in node.adjacent_iter():
        if not adjacent_node.is_colored:
            # avoid infinite loop
            _dfs_color(color, adjacent_node, nodes)

def dfs_color(color, node):
    nodes = set()
    _dfs_color(color, node, nodes)
    return nodes

class BipartiteGraph:
    def __init__(self):
        self.keyword_node_mapping = {}
        self.product_node_mapping = {}
        self.nodes = []

    def add_link(self, keyword, product, weight):
        if not self.keyword_node_mapping.has_key(keyword):
            node = Node(keyword)
            self.keyword_node_mapping[keyword] = node
            self.nodes.append(node)

        if not self.product_node_mapping.has_key(product):
            node = Node(product, is_keyword=False)
            self.product_node_mapping[product] = node
            self.nodes.append(node)

        keyword_node = self.keyword_node_mapping[keyword]
        product_node = self.product_node_mapping[product]

        keyword_node.add_adjacent(product_node)
        product_node.add_adjacent(keyword_node)

    def connected_components(self):
        components = {}
        color = 1
        for node in self.nodes:
            if not node.is_colored:
                components[color] = dfs_color(color, node)
                color += 1

        cluster_no = 1
        for color, component in components.iteritems():
            keyword_nodes, product_nodes = sieve(lambda n: n.is_keyword, component)

            print 'Cluster:', cluster_no
            print 'Keywords(%s):'%len(keyword_nodes), keyword_nodes
            print 'Products(%s):'%len(product_nodes), product_nodes
            print 

            cluster_no += 1

if __name__ == '__main__':
    with open('ratings.csv', 'rb') as f:
        reader = csv.reader(f)
        header = reader.next()
        bp_graph = BipartiteGraph()
        skipped_lines = []
        line = 2
        for row in reader:
            try:
                bp_graph.add_link(*row)
            except TypeError:
                skipped_lines.append(line)
            line += 1
        bp_graph.connected_components()
